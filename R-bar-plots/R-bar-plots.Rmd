---
title: "Bar Plots in R"
author: "J. R. Minter"
date: "Started: 2013-10-21, Last modified: 2020-05-19"
output:
  html_document:
    css: ../theme/jm-gray-vignette.css
    number_sections: yes
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA)
```

[Back to Index](../README.html)

```{r loadRequiredPackages, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(janitor)
library(colorspace)
library(ggplot2)
library(ggcharts)
library(dplyr)
library(mdthemes)
```

# Bar chart Examples from Thomas

Note: need to install `mdthemes`.

```
Sys.unsetenv("GITHUB_PAT")
remotes::install_github("thomas-neitmann/mdthemes")
```


Examples came (2020-04-20) from
[here](https://thomasadventure.blog/posts/labels-ggplot2-bar-chart/).

> I often see bar charts where the bars are directly labeled with the
value they represent. In this post I will walk you through how you can
create such labeled bar charts using ggplot2.

> The data I will use comes from the 2019 Stackoverflow Developer Survey.
To make creating the plot easier I will use the `bar_chart()` function from
my `ggcharts` package which outputs a `ggplot` that can be customized
further using any `ggplot2` function.

```{r createLangData}
dreaded_lang <- tibble::tribble(
  ~language, ~pct,
  "VBA", 75.2,
  "Objective-C", 68.7,
  "Assembly", 64.4,
  "C", 57.5,
  "PHP", 54.2,
  "Erlang", 52.6,
  "Ruby", 49.7,
  "R", 48.3,
  "C++", 48.0,
  "Java", 46.6
)

chart <- dreaded_lang %>%
  bar_chart(language, pct) %>%
  print()

```

> To add an annotation to the bars you’ll have to use either `geom_text()`
or geom_label(). I will start off with the former. Both require the label
aesthetic which tells ggplot2 which text to actually display. In addition,
both functions require the x and y aesthetics but these are already set
when using `bar_chart()` so I won’t bother setting them explicitly after
this first example

```{r addTextNow}
chart +
  geom_text(aes(x = language, y = pct, label = pct))
```

> By default the labels are center-aligned directly at the y value. You
will never want to leave it like that because it’s quite hard to read.
To left-align the labels set the hjust parameter to 0 or "left".

```{r chartLeftAlign}
chart +
  geom_text(aes(label = pct, hjust = "left"))

```

> That’s still not ideal I would say. Let’s move the labels a bit further
away from the bars by setting hjust to a negative number and increase the
axis limits to improve the legibility of the label of the top most bar.

```{r increaseLimits}
chart +
  geom_text(aes(label = pct, hjust = -0.2)) +
  ylim(NA, 100)
```

> Alternatively, you may want to have the labels inside the bars.

```{r labelsInsideBars}
chart +
  geom_text(aes(label = pct, hjust = 1))
```

> Again, a bit close to the end of the bars. By increasing the `hjust`
value the labels can be moved further to the left. In addition, black
on blue is quite hard to read so let’s change the text color to white.
**Notice that this happens outside of** `aes()`.

```{r increase_hjust}
chart +
  geom_text(aes(label = pct, hjust = 1.2), color = "white")
```


Next, let’s try `geom_label()` for once to see how it’s different from
`geom_text()`.

```{r use_geom_label}
chart +
  geom_label(aes(label = pct, hjust = 1.2))
```
> I am not a fan of this look and will stick to geom_text() for the final plot.
>
> As the data in the plot represents percentages it’s best practice to have
the labels include the percentage sign. In addition, let’s highlight our
favorite language R and add title, footnotes etc.

```{r use_r-best_practice}

dreaded_lang %>%
  mutate(label = sprintf("%1.1f%%", pct)) %>%
  bar_chart(language, pct, highlight = "R", bar_color = "black") +
  geom_text(aes(label = label, hjust = -0.1), size = 5) +
  scale_y_continuous(
    limits = c(0, 100),
    expand = expansion()
  ) +
  labs(
    x = NULL,
    y = "Developers Who are Developing with the Language but<br>Have not Expressed Interest in Continuing to Do so",
    title = "Top 10 Most Dreaded Programming Languages",
    subtitle = "*R Placed 8th*",
    caption = "Source: Stackoverflow Developer Survey 2019"
  ) +
  mdthemes::md_theme_classic(base_size = 14) +
  theme(
    axis.text.x = element_blank(),
    axis.line.x = element_blank(),
    axis.ticks.x = element_blank()
  )
```
> Notice how easy it was to highlight a single bar thanks to ggcharts.
In addition, I used my `mdthemes` package which provides themes that
interpret text as markdown. That way is was super easy to get the
subtitle in italics. Furthermore, I removed the axis labels and grid
lines. In my opinion you should never have an axis and labels in the
same plot.

> To finish off this post, let’s have a quick look at how to label a
vertical bar chart. It’s basically the same process but instead of
using `hjust` you will need to use `vjust` to adjust the label position.

```{r vert_bar_chart}

data("biomedicalrevenue")

biomedicalrevenue %>%
  filter(company == "Novartis") %>%
  mutate(label = sprintf("$%1.2f B.", revenue)) %>%
  column_chart(year, revenue) +
  geom_text(aes(label = label, vjust = -1)) +
  theme(
    axis.text.y = element_blank(),
    panel.grid.major.y = element_blank()
  ) +
  scale_x_continuous(
    name = "Fiscal Year",
    breaks = 2011:2018
  ) +
  scale_y_continuous(
    name = "Revenue (Billion USD)",
    limits = c(0, 70),
    expand = expansion()
  )
```

# Bar Chart Examples by Bruno Rodrigues

Bruno reported these examples on 2020-04-12

> Bar charts are quite simple plots, but there are enough variations of them
> that they deserve one single blog post. However, don’t expect many
> explanations.

> Let’s first start by loading some data, and the usually required packages:



## Load a data set

```{r loadData}
data(gss_cat)
```

> Very often, what one wants to show are counts:

```{r getCounts}
gss_cat %>%
  count(marital, race)
```

## Make an `other` category

> Let’s lump marital statuses that appear less than 10% of the time into an
> “Other” category:

```{r lumpCounts}
(
  counts_marital_race <- gss_cat %>%
    mutate(marital = fct_lump(marital, prop = 0.1)) %>%
    count(marital, race)
)
```

## Make the simplest bar plot

**_Nota Bene_**: In these examples I have replaced `brotools::theme_blog()`
with `theme_minimal()`.

```{r simplestBarPlot}

simple_plt <- ggplot(counts_marital_race) +
              geom_col(aes(x = marital, y = n, fill = race)) +
              scale_fill_discrete_qualitative(palette = "Dark 3") +
              theme_minimal() +
              NULL

print(simple_plt)
```

## Now with position = "dodge":

```{r simpleBarPlot2}
smp_plt_2 <- ggplot(counts_marital_race) +
             geom_col(aes(x = marital, y = n, fill = race),
                      position = "dodge") +
             scale_fill_discrete_qualitative(palette = "Dark 3") +
             theme_minimal() +
             NULL

print(smp_plt_2)
```

## Moving the legend around

We will use `theme(legend.position = ...)`:

```{r themeLegendPosition}
smp_plt_3 <- ggplot(counts_marital_race) +
             geom_col(aes(x = marital, y = n, fill = race),
                      position = "dodge") +
             scale_fill_discrete_qualitative(palette = "Dark 3") +
             theme_minimal() +
             theme(legend.position = "left") +
             NULL

print(smp_plt_3)

```

## Counting by year

We can count by year as well:

```{r countByYear}
(
  counts_marital_race_year <- gss_cat %>%
    mutate(marital = fct_lump(marital, prop = 0.1)) %>%
    count(year, marital, race) %>%
    ungroup()
)

```

## Track a variable change with time

> When you want to show how a variable evolves through time,
> an **area chart** is handy:

```{r AreaChart}

smpl_plt_4 <- counts_marital_race_year %>%
              group_by(year, marital) %>%
              summarise(n = sum(n)) %>%
              ggplot() +
              geom_area(aes(x = year, y = n, fill = marital)) +
              scale_fill_discrete_qualitative(palette = "Dark 3") +
              theme_minimal() +
              NULL

print(smpl_plt_4)

```

## Now use `facets`

```{r useFacets}
smpl_plt_5 <- counts_marital_race_year %>%
              ggplot() +
              geom_area(aes(x = year, y = n, fill = marital)) +
              facet_wrap(facets = vars(race), ncol = 1) +
              scale_fill_discrete_qualitative(palette = "Dark 3") +
              theme_minimal() +
              NULL

print(smpl_plt_5)

```

## `Facets` with individual `y-axis` scales

```{r indAxisYscales}
smpl_plt_6 <- counts_marital_race_year %>%
              ggplot() +
              geom_area(aes(x = year, y = n, fill = marital)) +
              facet_wrap(facets = vars(race), ncol = 1, scales = "free_y") +
              scale_fill_discrete_qualitative(palette = "Dark 3") +
              theme_minimal() +
              NULL

print(smpl_plt_6)

```

## An area chart but with **relative frequencies**

```{r areaChartRelFreq}

smpl_plt_7 <- counts_marital_race_year %>% 
              group_by(year, marital) %>% 
              summarise(n = sum(n)) %>%  
              mutate(freq = n/sum(n)) %>% 
              ggplot() +
              geom_area(aes(x = year, y = freq, fill = marital)) +
              scale_fill_discrete_qualitative(palette = "Dark 3") +
              theme_minimal() +
              NULL

print(smpl_plt_7)
```

## With `facet_wrap()`

```{r withFacetWrap}
smpl_plt_8 <- counts_marital_race_year %>% 
              group_by(race, year, marital) %>% 
              summarise(n = sum(n)) %>%  
              mutate(freq = n/sum(n)) %>% 
              ggplot() +
              geom_area(aes(x = year, y = freq, fill = marital)) +
              facet_wrap(facets = vars(race), ncol = 1, scales = "free_y") +
              scale_fill_discrete_qualitative(palette = "Dark 3") +
              theme_minimal() +
              NULL

print(smpl_plt_8)

```

## Fixing dates...

> Want to replace 2000 with “2000-01-01”? First need to create vector of
> prettier dates and positions?

### Create better dates

```{r createBetterDates}
pretty_dates <- counts_marital_race_year %>%
                mutate(pretty_dates = paste0(year, "-01-01")) %>%
                pull(pretty_dates) %>%
                unique()

position_dates <- counts_marital_race_year %>%
                  pull(year) %>%
                  unique() %>%
                  sort()
```

`scale_x_continuous()` can now use this. Using `guide = guide_axis(n.dodge = 2)`
to avoid overlapping labels:

```{r noOverLapLabels}
smpl_plt_9 <- counts_marital_race_year %>% 
              group_by(race, year, marital) %>% 
              summarise(n = sum(n)) %>%  
              mutate(freq = n/sum(n)) %>%
              ggplot() +
              geom_area(aes(x = year, y = freq, fill = marital)) +
              facet_wrap(facets = vars(race), ncol = 1, scales = "free_y") +
              scale_x_continuous("Year of survey", labels = pretty_dates,
                                  breaks = position_dates,
                                  guide = guide_axis(n.dodge = 2)) +
              scale_fill_discrete_qualitative(palette = "Dark 3") +
              theme_minimal() +
              NULL
print(smpl_plt_9)
```

### Getting labels right is a **major pain** in this case.

The author needed to do some rearanging (see the original...)

```{r rearrangedLabels}

smpl_plt_10 <- counts_marital_race_year %>% 
               group_by(race, year, marital) %>% 
               summarise(n = sum(n)) %>%  
               mutate(freq = n/sum(n)) %>%
               group_by(year, race) %>%  
               mutate(marital = fct_reorder(marital, freq)) %>% 
               arrange(desc(marital)) %>% 
               mutate(position = cumsum(freq)) %>%
               mutate(prev_pos = lag(position, default = 0)) %>%
               mutate(position = (position + prev_pos)/2) %>%  
               ggplot() +
               geom_area(aes(x = year, y = freq, fill = marital)) +
               facet_wrap(facets = vars(race), ncol = 1, scales = "free") +
               scale_x_continuous("Year of survey", labels = pretty_dates,
                                   breaks = position_dates,
                                   guide = guide_axis(n.dodge = 2)) +
               geom_label(aes(x = year, y = position,
                              label = round(100 * freq))) +
               scale_fill_discrete_qualitative(palette = "Dark 3") +
               theme_minimal() +
               NULL

print(smpl_plt_10)
```

I think that is getting pretty complicated...

## Consider the `tv_hours` varible

Now let’s focus on the variable tvhours. We want to show the total watched
hours, but also the total across all the categories of race and marital in a
faceted bar plot:

```{r tvHours}
(
  total_tv <- gss_cat %>%
    group_by(year, race, marital) %>%
    summarise(total_tv = sum(tvhours, na.rm = TRUE))
)
```

This tibble has the total watched hours by year, race and marital status
variables. How to add the total by year and race categories? For this, by are
first going to use the `group_split()`:


**NOTE** I could not get this part to work on R-3.6.3 on mac. I'm tired...

```
{r tvGroupSplit, warning=FALSE}

total_tv_split <- total_tv %>%
                  select(race, year, marital, total_tv) %>%
                  mutate(year = as.character(year)) # %>%  
                  # group_split(year, race)

print(total_tv_split)
```


I have to re-order the columns with select(), because when using
janitor::adorn_totals(), which I will be using below to add totals, the
first column must be a character column (it serves as an identifier column).

This creates a list with 3 races times 6 years, so 24 elements. Each element of 
the list is a tibble with each unique combination of year and race:



[Back to Index](../README.html)
